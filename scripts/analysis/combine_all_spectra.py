#### Reads in all of the ".dat" files generated by Veeper
#### and combines them into a single file, "all_spectra.h5"

import numpy as np
import glob
import os
import sys
import h5py as h5 

import eqwrange as eqw
import spec_helper_functions as shf


def best_measurement(veeper_col, veeper_colerr, aodm_col, aodm_colerr, flag, \
                         vel, vel_err, bval, bval_err):

    col_list = []; colerr_list = [], vel_list = []; vel_errlist = [];\
    bval_list = []; bvalerr_list = []; flag_list = []
    # first see if there are any good detections
    detected = (flag == 1) & (veeper_colerr > 0)
    sat      = (flag == 9)
    uplim    = (flag == 5)
    if len(veeper_col[detected]) > 0:
        if len(veeper_col[detected]) > 1:
            inds    = veeper_colerr[detected].argsort()            
            col_list.append(       veeper_col[detected][inds][0])
            colerrr_list.append(veeper_colerr[detected][inds][0])
            
            vel_list.append(       vel[detected][0])
            velerr_list.append(vel_err[detected][0])
            bval_list.append(       bval[detected][0])
            bvalerr_list.append(bval_err[detected][0])

        else:
            col_list.append(      veeper_col[detected])
            colerr_list.append(veeper_colerr[detected])

            vel_list.append(         vel[detected])
            velerr_list.append(  vel_err[detected])
            bval_list.append(       bval[detected])
            bvalerr_list.append(bval_err[detected])
        
        flag_list.append(1)

    elif len(veeper_col[sat]) > 0:
        if len(veeper_col[sat]) > 1:
            inds = aodm_col[sat].argsort()
            col_list.append(aodm_col[sat][inds][0])
            colerr_list.append(aodm_err[sat][inds][0])
            
            vel_list.append(       vel[sat][0])
            velerr_list.append(vel_err[sat][0])
            bval_list.append(       bval[sat][0])
            bvalerr_list.append(bval_err[sat][0])
        else:
            col_list.append(aodm_col[sat])
            colerr_list.append(aodm_err[sat])

            vel_list.append(       vel[sat])
            velerr_list.append(vel_err[sat])
            bval_list.append(       bval[sat])
            bvalerr_list.append(bval_err[sat])
        flag_list.append(9)

    elif len(veeper_col[uplim]) > 0:
        if len(veeper_col[uplim]) > 1:
            inds = aodm_col[uplim].argsort()
            col_list.append(    aodm_col[uplim][inds][0])
            colerr_list.append(aodm_colerr[sat][inds][0])

        else:
            col_list.append(      aodm_col[uplim])
            colerr_list.append(aodm_colerr[uplim])


        vel_list.append(-9999)
        velerr_list.append(-9999)
        bval_list.append(-9999)
        bvalerr_list.append(-9999)
        
        flag_list.append(5)

    return col_list, colerr_list, vel_list, velerr_list, bval_list, bvalerr_list, flag_list

master_ion_list = ['HI', 'OVI', 'CII', 'CIII', 'SiII', 'SiIII', 'SiIV',  'NIII', 'NV']
#restwave_list = [1215.67, 1031.9261, 1037.0182, 1334.5323

work_dir = '../../data/analyzed_spectra'
spec_outfile = h5.File('combined_spectra.h5', 'w')


orientation_list = [];      model_list = [];   time_list = [];  redshift_list = []; 
impact_list      = [];   restwave_list = [];    ion_list = [];       col_list = []; 
sigcol_list      = [];       bval_list = [];    vel_list = [];   sigbval_list = []; 
sigvel_list      = [];       flag_list = []; flag_aodm_list = []; 
eqw_list         = [];     sigeqw_list = [];  lncol_list = [];  siglncol_list = []; 
velcent_list     = [];   velwidth_list = []; ewjson_list = []; sigewjson_list = []; 
coljson_list     = []; sigcoljson_list = [];

# looping through all of the analyzed spectra
os.chdir(work_dir)
spec_files = glob.glob('COS-FUV*')
#spec_files = ['COS-FUV_face_anisd_11.2Gyr_r10kpc']
for spec in spec_files:
    orientation, model = np.loadtxt('%s/info.txt'%(spec), skiprows = 1, unpack = False, usecols = (0, 1), dtype = str)
    time, redshift, impact = np.loadtxt('%s/info.txt'%(spec), skiprows = 1, unpack = True, usecols = (2, 3, 4))

    veeper_fn = '%s/compiledVPoutputs.dat'%(spec)
    json_fn = '%s/%s_lineids.json'%(spec, spec)
    json_out = '%s/json_eqw.dat'%(spec)
    aodm_fn = '%s/%s_ibnorm.fits'%(spec, spec)
    aodm_plot_dir = '%s/aodm_plots'%(spec)
    if not os.path.isdir(aodm_plot_dir):
        os.mkdir(aodm_plot_dir)

    if os.path.isfile(veeper_fn):
        restwaves, cols, sigcols, bvals, sigbvals, vels, sigvels, flags = np.loadtxt(veeper_fn, unpack=True, skiprows = 1, \
                    usecols = (1,3,4,5,6,7,8, 9), delimiter = '|')
        veeper_ions = np.loadtxt(veeper_fn, unpack=True, skiprows = 1, usecols = (19), dtype = 'str', delimiter = '|')  
    else:
        restwaves = []; cols = []; sigcols = []; bvals = []; sigbvals = []; 
        vels      = []; sigbvels = []; flags = []; veeper_ions = [];    
    
    for i in range(len(veeper_ions)):
        temp    = veeper_ions[i]
        veeper_ions[i] = temp.replace(" ", "")

    json_ions, json_restwaves, json_eqw, json_eqwerr, json_col, json_colerr = eqw.json_eqw(json_fn, aodm_fn, json_out)
    dummy = -9999.
    print(spec)
    for i in range(len(master_ion_list)):
        ion = master_ion_list[i].replace(" ", "")
        all_restwaves = shf.all_restwaves(ion)
        for rw in all_restwaves:
            ncopies = 1
            index = (veeper_ions == ion) & (restwaves == rw)
 #           print('veeper', veeper_ions[index], cols[index], sigcols[index])
            if ion in veeper_ions and len(veeper_ions[index]) > 0:
                if len(veeper_ions[index]) > 1:
                    ncopies += len(veeper_ions[index]) - 1
 #                   print(ncopies)
                restwave_list = np.append(restwave_list,   ncopies*[rw])
                ion_list      = np.append(ion_list,       ncopies*[ion])
                col_list      = np.append(col_list,         cols[index])
                sigcol_list   = np.append(sigcol_list,   sigcols[index])
                bval_list     = np.append(bval_list,       bvals[index])
                sigbval_list  = np.append(sigbval_list, sigbvals[index])
                vel_list      = np.append(vel_list,         vels[index])
                sigvel_list   = np.append(sigvel_list,   sigvels[index])
                flag_list     = np.append(flag_list,       flags[index])

            else:
                restwave_list = np.append(restwave_list,    rw)
                ion_list      = np.append(ion_list,        ion)
                col_list      = np.append(col_list,      dummy)
                sigcol_list   = np.append(sigcol_list,   dummy)
                bval_list     = np.append(bval_list,     dummy)
                sigbval_list  = np.append(sigbval_list,  dummy)
                vel_list      = np.append(vel_list,      dummy)
                sigvel_list   = np.append(sigvel_list,   dummy)
                flag_list     = np.append(flag_list,     dummy)

            
            json_index = (json_ions == ion) & (json_restwaves == rw)
#            print('json:', json_ions[json_index], json_col[json_index], json_colerr[json_index])

            if ion in json_ions and len(json_ions[json_index]) > 0:
                if len(json_ions[json_index]) > ncopies:
                    ewjson_list     = np.append(ewjson_list,        json_eqw[json_index][:ncopies])
                    sigewjson_list  = np.append(sigewjson_list,  json_eqwerr[json_index][:ncopies])
                    coljson_list    = np.append(coljson_list,       json_col[json_index][:ncopies])
                    sigcoljson_list = np.append(sigcoljson_list, json_colerr[json_index][:ncopies])
                elif len(json_ions[json_index]) == 1 and ncopies > 1:
                    ewjson_list     = np.append(ewjson_list,        [json_eqw[json_index]]*ncopies)
                    sigewjson_list  = np.append(sigewjson_list,  [json_eqwerr[json_index]]*ncopies)
                    coljson_list    = np.append(coljson_list,       [json_col[json_index]]*ncopies)
                    sigcoljson_list = np.append(sigcoljson_list, [json_colerr[json_index]]*ncopies)
                else:
                    ewjson_list     = np.append(ewjson_list,        json_eqw[json_index])
                    sigewjson_list  = np.append(sigewjson_list,  json_eqwerr[json_index])
                    coljson_list    = np.append(coljson_list,       json_col[json_index])
                    sigcoljson_list = np.append(sigcoljson_list, json_colerr[json_index])
            else:
                ewjson_list     = np.append(ewjson_list,     ncopies*[dummy])
                sigewjson_list  = np.append(sigewjson_list,  ncopies*[dummy])
                coljson_list    = np.append(coljson_list,    ncopies*[dummy])
                sigcoljson_list = np.append(sigcoljson_list, ncopies*[dummy])

  #          print(len(col_list), len(coljson_list))
                
            impact_list      = np.append(impact_list,           ncopies*[impact])
            model_list       = np.append(model_list,             ncopies*[model])
            orientation_list = np.append(orientation_list, ncopies*[orientation])
            time_list        = np.append(time_list,               ncopies*[time])
            redshift_list    = np.append(redshift_list,       ncopies*[redshift])
          

            eqws, sigeqw, lncol, siglncol, flag_aodm, velcent, velwidth = \
                eqw.find_ion_limits(ion, aodm_fn, [ion], orientation, model, impact, restwave = rw, \
                                        redshift = redshift, silent = 1, plots = 0, plot_dir = aodm_plot_dir, \
                                        vrange = (-150, 150), sat_limit = 0.1)
            flag_aodm_list= np.append(flag_aodm_list, ncopies*[flag_aodm[0]])
            eqw_list      = np.append(eqw_list,            ncopies*[eqws[0]])
            sigeqw_list   = np.append(sigeqw_list,       ncopies*[sigeqw[0]])
            lncol_list    = np.append(lncol_list,         ncopies*[lncol[0]])
            siglncol_list = np.append(siglncol_list,   ncopies*[siglncol[0]])
            velcent_list  = np.append(velcent_list,     ncopies*[velcent[0]])
            velwidth_list = np.append(velwidth,        ncopies*[velwidth[0]])
            


dataset_names = ['impact', 'time', 'redshift', 'restwave', 'col', 'colerr', 'bval', 'bvalerr', 'vel', 'velerr', 'flag', 'flag_aodm', \
                     'eqw_aodm', 'eqw_aodm_err', 'col_aodm', 'col_aodm_err', 'vel_aodm', 'velwidth_aodm', 'col_json', 'col_json_err', \
                     'eqw_json', 'eqw_json_err']
datasets = [impact_list, time_list, redshift_list, restwave_list, col_list, sigcol_list, bval_list, sigbval_list, vel_list, sigvel_list, \
                flag_list, flag_aodm_list, eqw_list, sigeqw_list, lncol_list, siglncol_list, velcent_list, velwidth_list, coljson_list, \
                sigcoljson_list, ewjson_list, sigewjson_list]

# first save the numerical data   
for dset, data in zip(dataset_names, datasets):
    print(dset)
    spec_outfile.create_dataset(dset, data = data)


# then save string-type data in a special way     
dt = h5.special_dtype(vlen=str)
dataset_names = ['model', 'orientation', 'ion']
datasets = [model_list, orientation_list, ion_list]
for dset, data in zip(dataset_names, datasets):
    print(dset)
    current_dset = spec_outfile.create_dataset(dset, (len(data),), dtype=dt)
    for i in range(len(data)):
        current_dset[i] = data[i].replace(" ", "")


spec_outfile.close()
            
                    
                    



